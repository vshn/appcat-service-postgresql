= Decision: User And Database Management

== Problem

A single PostgreSQL server instance can hold multiple roles (users) and databases.
The problem is to decide which kind of credentials or user management options is exposed for the service consumer.
This page investigates methods to manage those both from an API PoV as well as implementation.

Also relevant is the xref:explanations/decision-deployment-strategy.adoc[Decision: Deployment Strategy], where it was decided to use a Helm-based deployment, which affects the implementation.

=== Implementation Notes

Any proposal that offers multi-user and multi-database management features have to fulfill the "reconciliation contract".
Meaning there needs to be mechanisms that cleanup unknown and unmanaged resources.

== Proposals

=== Proposal 1: Single Non-Privileged User and Database

The most simple and straightforward solution is to only expose a fixed set of credentials for a single, non-privileged PostgreSQL role that can access only 1 database.
It's not possible to add roles or database to the instance.

While this solution is simple to implement, users may soon request more flexibility without having to order new service instances.

=== Proposal 2: Exposed Superuser

This option exposes a fixed set of credentials for the `postgres` superuser.
Users can freely manage databases and roles on their own.
There exist also applications that manage the databases and roles on their own and actually require superuser permissions.

There is a risk that users may potentially do harmful operations and break their own instance.
Also, at the same time users may be wary of this kind of elevated permissions exactly for the same reason and for security concerns.

Like Proposal 1 this should be easy to implement.

=== Proposal 3: Manage Users and Databases in the same CR

The same CR that specifies the high-level parameters around the service instance (for example Backup, Monitoring, etc) also exposes fields to configure databases and roles.

.API Spec illustration
[example]
====
[source,yaml]
----
apiVersion: postgresql.appcat.vshn.io/v1alpha1
kind: PostgresqlStandalone
metadata:
  name: my-instance
spec:
  users:
    - name: my-app-user
      passwordFromSecret: # optional, autogenerated if not provided
        secretName: ""
        key: ""
  databases:
    - name: my-app-db
      owner: my-app-user # must be defined in the `users` list
----
====

Special handling needs to be given in cases where databases or users are deleted.
This method allows more elaborate use cases, for example dynamically deploy a preview of an environment and remove it afterwards.

[TIP]
====
It may be worthwile to consider a default database and user if no user or database is defined in the spec.
This should keep the spec simple for users that don't require more than 1 user or database for their use case.
====

[NOTE]
====
It's possible that the chosen Helm chart doesn't support user management for more than 1 user and database.
Therefore this proposal likely requires additional engineering to ensure that these users and databases exist when provisioning (including cleanup).
This could be done either in a forked Helm chart or directly in code in the operator (however, code and chart must "match" for all deployed chart versions).
====

=== Proposal 4: Manage Users and Databases in another CR

Similar to how https://github.com/crossplane-contrib/provider-sql/tree/v0.4.1/examples/postgresql[Crossplane Provider SQL] does it, provide resources where the user management is declarative and outside of the service instance CRD.

.API Spec illustration
[example]
====
[source,yaml]
----
apiVersion: postgresql.appcat.vshn.io/v1alpha1
kind: Database
metadata:
  name: my-app-db
spec:
  instanceRef: my-instance
---
apiVersion: postgresql.appcat.vshn.io/v1alpha1
kind: Role
metadata:
  name: my-app-user
spec:
  instanceRef: my-instance
  passwordFromSecret: # optional, autogenerated if not provided
    secretName: ""
    key: ""
---
apiVersion: postgresql.appcat.vshn.io/v1alpha1
kind: Grant
metadata:
  name: grant-role-my-app-user-on-my-app-db
spec:
  instanceRef: my-instance
  privileges:
    - ALL
  roleRef:
    name: my-app-user
  databaseRef:
    name: my-app-db
----
====

Special handling needs to be given in cases where databases or users are deleted.
This method allows more elaborate use cases, for example dynamically deploy a preview of an environment and remove it afterwards.
The advantage of this proposal over Proposal 3 is that the main resource doesn't need to be altered and this API scheme allows flexible GitOps scenarios.

[TIP]
====
* It may be worthwile to consider a default database and user if no user or database is defined in the spec.
  This should keep the spec simple for users that don't require more than 1 user or database for their use case.
* It may be worth considering to use https://github.com/crossplane-contrib/provider-sql[Provider SQL] as the implementation.
  However, the same versioning issues arise when using foreign CRDs as described in xref:explanations/decision-deployment-strategy.adoc[Decision: Deployment Strategy].
====

[NOTE]
====
It's possible that the chosen Helm chart doesn't support user management for more than 1 user and database.
Therefore this proposal likely requires additional engineering to ensure that these users and databases exist when provisioning (including cleanup).
This could be done either in a forked Helm chart or directly in code in the operator (however, code and chart must "match" for all deployed chart versions).
====

== Decision

Proposal 2: Exposed Superuser

== Rationale

The service instance shouldn't be limited to 1 single user and database.
For the first iteration a sophisticated multi-user and -database management is considered too early and may be added in a later iteration at the cost of migration effort.

At the same time, the first iteration shouldn't limit the user or use cases where apps bring their own management system.
That is why the superuser is being exposed.
The risk where users can screw up their own instance (where service engineers have to fix the instance via support request) is deemed acceptable.

NOTE: This decision currently applies to the PostgreSQL service in standalone mode.
